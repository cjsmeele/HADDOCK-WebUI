"use strict";

/**
 * form.js - HADDOCK form generator
 */

/**
 * Coding style for this script:
 *
 * Write strict-mode compliant JavaScript. See:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode#Changes_in_strict_mode
 *
 * Casing: camelCase  for variables and methods
 *         PascalCase for classes
 *         UPPER_CASE for constants
 *
 * Opening braces:       on the same line
 * Spaces around braces: only for inline functions: `function(){ a=1; }`
 *
 * Indentation: tabs (in short: noet sw=4 ts=4)
 * Alignment:   spaces (align assignments, string concats, etc.)
 *
 * Documentation: docblocks before every function
 *
 * Wrapping: recommended but not required, at column 120 or 80
 *           (assume a tab width of 4 characters)
 *
 * Use single quotes for strings unless quote escaping hinders readability.
 *
 * Aim for compatibility with Firefox 24+, Chrome 33+, Safari 5.1+ and IE10+*.
 * Using jQuery where appropriate, there really shouldn't be any compatibility issues.
 *
 * * IE10 is the lowest IE version that supports JS FormData, which we need for
 *   asynchonously submitting forms with files.
 */

/**
 * The execution order of this script is as follows:
 *
 * - Does a localStorage cache entry exist for the form HTML and is it up-to-date?
 *   - Yes:
 *     - Load form HTML into #haddockform > .content
 *   - No:
 *     - Use buildForm() to generate form HTML
 *       - Recursively generate component instances and their HTML
 *         - Render sections with makeSectionRepetitions()
 *           - Render paragraphs with makeParagraph()
 *           - Render parameters with makeParameterRepetitions()
 *             - Render parameter values with makeValue()
 *     - Load form HTML into #haddockform > .content
 * - finalizeForm()
 *   - Attach event handlers
 *   - Set form level with setLevel() to a predefined value
 *   - Fold sections
 *   - Show the form
 *
 *
 * Further information on how form component objects are used by this script:
 *
 * `components[]` is a tree of components as generated by a CNS parser.
 * All components in this tree have a `type` property.
 * This type must be one of the following:
 * - `section`
 * - `parameter`
 * - `paragraph`
 *
 * Properties of components in this tree are attributes that define data types,
 * component repetition, default values, the required access levels, etc.
 *
 * Sections component objects contain a `children[]` array which can contain
 * child components of any type.
 *
 * On page load, the script goes through the components array and generates two
 * other component lists: `componentData[]` and `componentInstances[]`.
 *
 * `componentData[]` is basically a flat version of the `component[]` list. It is
 * used to provide quick access to a component's information using an index
 * number. Indices are saved in data-data-index attributes on HTML elements.
 *
 * `componentInstances[]` will be filled with instances of components.
 * Component instances contain a reference to a `components[]` object, and
 * depending on the component type:
 * - A reference to a parent instance (and it's repeat index) if this is not a root component
 * - An index in the componentInstances[] array
 * - An index in the component's own instances array
 * - A list of repetitions for this instance, which contains:
 *   (for sections:)
 *   - A list of child component instances, for each repetition
 *   (for parameters:)
 *   - A list of parameter values, for each repetition
 *
 * Instances are occurrences of a component within a parent component, in the
 * sense that repeated parent blocks each have their own child component
 * instances.
 * Repetitions for the component itself do not create separate instances for
 * that component, repetition data is instead saved in the `repetitions[]`
 * property.
 *
 * Consider the following form structure, where Parameter Y has 2 instances:
 *
 * - instance (section X)
 *   repetitions: [
 *     (1) [
 *       - childInstance (parameter Y)
 *         repetitions: [
 *           0, 1, 9   // Parameter Y is repeatable and has 1 to 3 values
 *         ]
 *       ...
 *     ]
 *     (2) [
 *       - childInstance (parameter Y)
 *         repetitions: [
 *           4, 2
 *         ]
 *       ...
 *     ]
 *   ]
 *
 *
 * During instance generation, a HTML string is generated for the initial form.
 * When all initial instances have been created, this HTML string is inserted
 * into the form container (`#haddockform > .content`).
 * At this point, event handlers can be attached to the form.
 *
 * The initial HTML and instances as generated above are also stored in
 * localStorage, to allow clients to skip the rendering step after the first
 * time (but of course, changes to the data model will be detected and will
 * trigger a regeneration).
 *
 *
 * TODO:
 *
 * Some issues that may need to be solved sooner or later, but don't currently
 * break the script's functionality:
 *
 * - renderComponents() and makeSection() contain duplicated code.
 *
 * - Object Orientation (e.g. instance.addRepetition()) would make the code more
 *   readable and easier to understand. However, this would introduce additional
 *   difficulties with caching (we can't serialize function objects).
 *
 * - The necessity of client-side caching may need to be re-evaluated. Caching was
 *   considered necessary before certain "optimalizatons" were dropped, because
 *   of slow HTML generation. Form building has sped up significantly since this
 *   decision was made, to the point where loading times were about 1s on fast
 *   PCs.
 *   Dropping the cache would simplify some code and make OO possible (see above)
 *
 * - Radio buttons for choice datatypes with few options are currently not supported
 *
 * - Check boxes for true/false choices are currently not supported
 */

// Don't add properties to global scope
$(function(){

	// Avoid modifying global variables, bring them into local scope.
	var formLevels     = window.formLevels;
	var formLevelIndex = window.formLevelIndex;
	var userLevel      = window.userLevel;

	// Note that the members of formComponents[] as provided by the webserver
	// follow a lowercase/underscore naming convention.
	var rootComponents     = window.formComponents; // Component JSON data in a tree structure.
	var componentData      = []; // Flat version of formComponents[] / rootComponents[].
	var rootInstances      = []; // Component instances at the root level (for tree-structure looping).
	var componentInstances = []; // Actual spawned sections and parameters, flat list.

	var componentCount         = 0;
	var componentInstanceCount = 0;
	var instancesRendered      = 0;

	var formHasChanged   = false;
	var formLevelTooHigh = false;
	var formReady        = false;

	var formVersion = null;

	/**
	 * Change the form level.
	 *
	 * @param name the level name to switch to
	 * @param force show/hide components even if we are already on the specified level
	 */
	function setLevel(name, force){
		if(
				$('.levelchooser li.selected')[0] === $('.levelchooser li.level-'+name)[0]
				&& force !== true
			){
			// We are already at the right level
			return;
		}

		if(!formLevelTooHigh && formLevels.indexOf(name) < formLevelIndex && formHasChanged && force !== true){
			// Because lower form levels hide certain fields, the user may lose
			// filled in data by switching to a lower form level.
			// Although we do not reset input fields, we should warn the user
			// that some parameters may not be saved.
			// Of course, we filter submitted fields based on access level on the server side as well.
			if(!confirm(
					'You may lose filled in parameters by switching to a lower form level.'
					+ "\nAre you sure you want to switch to the " + name + ' form?'
				)){
				return;
			}
		}

		formHasChanged = false;

		// Mark the level element in the chooser as selected
		$('.levelchooser li.selected').removeClass('selected');
		$('.levelchooser li.level-'+name).addClass('selected');

		formLevelIndex = formLevels.indexOf(name);

		var rowsToHide = $('#haddockform .row:not([class~="level-' + name + '"])');
		var rowsToShow = $('#haddockform .row.level-' + name);

		if(Config.hideDisabledComponents){
			rowsToHide.hide();
			rowsToShow.show();
		}

		// Disable hidden input elements just in case
		rowsToHide.find('> .values input, > .values select').prop('disabled', true);
		rowsToShow.find('> .values input, > .values select').prop('disabled', false);

		if(formLevelIndex > userLevel){
			formLevelTooHigh = true;

			$('.levelwarning').html(
				'<p>'
				+ ' <i class="fa fa-warning"></i>'
				+ ' Warning: Because your current access level is not high enough for the ' + name + ' interface,'
				+ ' you will be unable to submit this form.'
				+ ' Please <a href="mailto:/dev/null">request a higher access level</a> or choose a different form level above.'
				+ '</p>'
			);
			$('.levelwarning').slideDown(80);
			$('#haddockform input[type="submit"]').prop('disabled', true);
		}else{
			formLevelTooHigh = false;

			$('.levelwarning').slideUp(80);
			$('#haddockform input[type="submit"]').prop('disabled', false);
		}
	}

	/**
	 * Fold or unfold a section.
	 *
	 * @param section
	 * @param batch if true, do not attempt to animate folding
	 */
	function toggleSection(section, batch){
		var toggleButton = $(section).find('header > .togglebutton')[0];

		if($(section).hasClass('folded')){
			$(toggleButton).removeClass('fa-angle-double-up');
			$(toggleButton).addClass('fa-angle-double-down');
			$(section).removeClass('folded');
			if(batch === true)
				$($(section).find('.content')[0]).show();
			else
				$($(section).find('.content')[0]).slideDown(80);
		}else{
			$(toggleButton).removeClass('fa-angle-double-down');
			$(toggleButton).addClass('fa-angle-double-up');
			$(section).addClass('folded');
			if(batch === true)
				$($(section).find('.content')[0]).hide();
			else
				$($(section).find('.content')[0]).slideUp(80);
		}
	}

	/**
	 * Update the loading progressbar with a fraction.
	 *
	 * @param fraction a floating point number (0.0 - 1.0) indicating progress
	 */
	function setProgress(fraction){
		if(fraction > 1)
			fraction = 1;
		else if(fraction < 0)
			fraction = 0;

		var progressbar = $('#progressbar');
		progressbar.removeClass('indeterminate');
		progressbar.css('width', (fraction * 100) + '%');
	}

	/**
	 * Resets an input, select or checkbox group to its default value.
	 *
	 * @param input the element to reset
	 */
	function resetInput(input){
		var buttonSet = $(input).parent('.value').find('.buttonset');
		input.val(input.attr('data-default'));

		if(input.is('input[type="text"]')){
			input.val(input.attr('data-default'));
		}else if(input.is('select')){
			input.val(input.attr('data-default'));
		}else if(input.is('.checkgroup')){
			// TODO: Radio buttons are currently not supported

			// Now let's just hope the default value doesn't contain double quotes...
			//input.find('input[type="radio"][value="' + input.attr('data-default') + '"]').prop('checked', true);
		}

		$(buttonSet).find('i.reset').addClass('invisible');
	}

	// Multi- section/parameter code {{{

	/*
	 * NOTE: These functions assume that adding / removing repetitions is
	 *       allowed, i.e. that by doing so the repeat_min and repeat_max
	 *       values are not exceeded.
	 *       Because add/remove buttons are only visible when that action is
	 *       allowed, this isn't that much of a problem, but if one were to
	 *       call these functions manually (e.g. in a script that auto-fills
	 *       other form elements based on filled in data) they must do these
	 *       checks themselves.
	 */

	/**
	 * Remove the last section repetition of an instance.
	 *
	 * @param instance the section's instance
	 */
	function removeSectionRepetition(instance){
		var sectionRow = $('#haddockform .row[data-global-instance-index="' + instance.globalIndex + '"]');

		/**
		 * Remove section child instances recursively
		 *
		 * @param sectionInstance
		 * @param repeatIndex the repeatIndex of sectionInstance to clear
		 */
		function removeChildInstances(sectionInstance, repeatIndex){
			// For each child
			for(var i=0; i<sectionInstance.repetitions[repeatIndex].length; i++){
				var instance = sectionInstance.repetitions[repeatIndex][i];
				if(instance.component.type === 'section' && instance.repetitionCount > 0){
					// For each child section repetition
					// Loop backwards to allow splice to work
					for(var j=instance.repetitions.length-1; j>=0; j--){
						removeChildInstances(instance, j);
					}
				}
				// We can't splice componentInstances[] because index numbers are saved
				// everywhere. Set this entry to null instead, so it can be GCed.
				componentInstances[instance.globalIndex] = null;
			}
			sectionInstance.repetitions.splice(repeatIndex, 1);
		}

		removeChildInstances(instance, instance.repetitionCount-1);
		instance.repetitionCount--;

		var lastRepetition = sectionRow.children(':last-child');
		lastRepetition.remove();

		// Show and hide add / remove buttons
		if(instance.repetitionCount > 0){
			var lastButtonSet = sectionRow.children(':last-child').find('> header > .buttonset');
			lastButtonSet.find('.plus').removeClass('invisible');
			if(instance.repetitionCount > instance.component.repeat_min)
				lastButtonSet.find('.minus').removeClass('invisible');
		}

		sectionRow.find('> section > header .repetition-count').html(instance.repetitionCount);

		if(instance.repetitionCount === 0 && instance.hasDummy){
			sectionRow.children('.dummy').show();
		}
	}

	/**
	 * Remove a parameter instance's last value.
	 *
	 * @param instance the parameter's instance
	 */
	function removeParameterRepetition(instance){
		var valueTable =
			$('#haddockform .row[data-global-instance-index="' + instance.globalIndex + '"]')
				.find('.values.table');

		instance.repetitionCount--;
		instance.repetitions.pop();

		// Remove the last value row from the DOM.
		var lastValue = valueTable.children(':last-child');
		lastValue.remove();

		// Show and hide add / remove buttons
		if(instance.repetitionCount > 0){
			var lastButtonSet = valueTable.children(':last-child');
			lastButtonSet.find('.plus').removeClass('invisible');
			if(instance.repetitionCount > instance.component.repeat_min)
				lastButtonSet.find('.minus').removeClass('invisible');
		}

		valueTable.find('.repetition-count').html(instance.repetitionCount);

		if(instance.repetitionCount === 0 && instance.hasDummy){
			valueTable.children('.dummy').show();
		}
	}

	/**
	 * Add a section repetition.
	 *
	 * @param instance the section's instance
	 */
	function addSectionRepetition(instance){
		var sectionRow = $('#haddockform .row[data-global-instance-index="' + instance.globalIndex + '"]');

		// Repetition count is used by makeButtonSet(), update it first.
		instance.repetitionCount++;

		if(instance.hasDummy)
			sectionRow.children('.dummy').hide();

		var repeatIndex = instance.repetitionCount - 1;

		// makeSection() handles instance creation and inserts its own repetition for us,
		// this differs from how addParameterRepetition() works.
		var section   = makeSection(instance, repeatIndex, true);
		var sectionEl = $(section.html);

		{ // Hide children with higher access levels. See setLevel().
			var rowsToHide = sectionEl.find('.row:not([class~="level-' + formLevels[formLevelIndex] + '"])');

			if(Config.hideDisabledComponents)
				rowsToHide.hide();

			// Disable hidden input elements just in case
			rowsToHide.find('> .values input, > .values select').prop('disabled', true);
		}

		// Fold the new sections' child sections. Keep the section itself unfolded.
		sectionEl.find('section').each(function(){
			toggleSection($(this), true);
		});

		// Show and hide add / remove buttons
		if(instance.repetitionCount > 1){
			var lastButtonSet = sectionRow.children(':last-child').find('> header > .buttonset');
			lastButtonSet.find('.plus').addClass('invisible');
			lastButtonSet.find('.minus').addClass('invisible');
		}

		sectionRow.find('> section > header .repetition-count').html(instance.repetitionCount);
		sectionRow.append(sectionEl);
	}

	/**
	 * Add a parameter value.
	 *
	 * @param instance the parameter's instance
	 */
	function addParameterRepetition(instance){
		var valueTable  =
			$('#haddockform .row[data-global-instance-index="' + instance.globalIndex + '"]')
				.find('.values.table');

		// Repetition count is used by makeButtonSet(), update it first.
		instance.repetitionCount++;

		if(instance.hasDummy)
			valueTable.children('.dummy').hide();

		var repeatIndex = instance.repetitionCount - 1;
		var value       = makeValue(instance, repeatIndex);

		instance.repetitions.push(value.value);

		// Show and hide add / remove buttons
		if(instance.repetitionCount > 1){
			var lastButtonSet = valueTable.children(':last-child');
			lastButtonSet.find('.plus').addClass('invisible');
			lastButtonSet.find('.minus').addClass('invisible');
		}

		// Currently, no repetition-count spans are added to parameter
		// button sets, so this has no effect.
		valueTable.find('.repetition-count').html(instance.repetitionCount);

		// Insert the new value row.
		valueTable.append(value.html);
	}

	// }}}
	// Event handlers {{{

	/**
	 * Event handler for reset buttons.
	 *
	 * @param e a click event
	 */
	function onResetButton(e){
		var buttonSet = $(this).parent('.buttonset');
		var input = buttonSet.parent('.value').find('input, select');
		resetInput(input);

		e.preventDefault();
		e.stopPropagation();
	}

	/**
	 * Event handler for minus buttons.
	 *
	 * @param e a click event
	 */
	function onMinusButton(e){
		var buttonSet = $(this).parent('.buttonset');
		var row       = $($(this).parents('.row')[0]);
		var instance  = componentInstances[row.data('global-instance-index')]

		if(buttonSet.is('.section-buttons')){
			removeSectionRepetition(instance);
		}else if(buttonSet.is('.parameter-buttons')){
			removeParameterRepetition(instance);
		}

		// Stop click events from reaching the header and folding this section
		e.preventDefault();
		e.stopPropagation();
	}

	/**
	 * Event handler for plus buttons.
	 *
	 * @param e a click event
	 */
	function onPlusButton(e){
		var buttonSet = $(this).parent('.buttonset');
		var row       = $($(this).parents('.row')[0]);
		var instance  = componentInstances[row.data('global-instance-index')]

		if(buttonSet.is('.section-buttons')){
			addSectionRepetition(instance);
		}else if(buttonSet.is('.parameter-buttons')){
			addParameterRepetition(instance);
		}

		e.preventDefault();
		e.stopPropagation();
	}

	/**
	 * Submit the form in JSON format
	 */
	function onSubmit(e){
		// FIXME: Chromium breaks when fields that don't validate are hidden at the time of a submit.
		//        To avoid this problem, the form element now has the 'novalidate' attribute.
		//        We should probably call the validation function manually on input value change.

		/**
		 * Package a section or parameter component instance for submission.
		 *
		 * @param instance a parameter or section instance
		 */
		function packageInstance(instance){
			if(instance.component.type !== 'section' && instance.component.type !== 'parameter'){
				// This shouldn't happen.
				alert('Error: Cannot package instance of type "' + instance.component.type + '"');
				return;
			}

			var entry = {
				// Note that the server expects JSON post data in lowercase/underscores format.

				// As long as the server uses the same data model, component
				// numbers should remain the same.
				component_index: instance.component.dataIndex,
				repetitions:     []
			};

			for(var i=0; i<instance.repetitionCount; i++){
				// For each repetition...

				// We do not leave out parameters that we shouldn't have access to.
				// It is the server's job to check what parameters we can and cannot set.

				if(instance.component.type === 'section'){
					var repetition = []; // Contains child instances
					for(var j=0; j<instance.repetitions[i].length; j++){
						// For each child instance...
						if(instance.repetitions[i][j].component.type === 'section'
								|| instance.repetitions[i][j].component.type === 'parameter'){
							repetition.push(packageInstance(instance.repetitions[i][j]));
						}
					}
					entry.repetitions.push(repetition);
				}else if(instance.component.type === 'parameter'){
					// Push parameter value i.

					// Grab an up to date value from the ith input element.
					var element = $('#haddockform .row[data-global-instance-index="'
						+ instance.globalIndex
						+ '"] .value:not(.dummy)').find('input, select').eq(i);

					entry.repetitions.push(element.val());
				}
			}

			return entry;
		}

		try {
			var postData = {
				form_version: formVersion,
				level:        formLevels[formLevelIndex],
				instances:    []
			};

			// First create an acyclic tree structure to hold all instances that we
			// need to submit.

			for(var i=0; i<rootInstances.length; i++){
				if(rootInstances[i].component.type !== 'section'
						&& rootInstances[i].component.type !== 'parameter'){
					// Filter out data-less component types
					continue;
				}
				postData.instances.push(packageInstance(rootInstances[i]));
			}

			var formData = new FormData();
			formData.append('json', JSON.stringify(postData));


			var fileInstances = { };

			$('#haddockform input[type="file"]').each(function(){
				// Use the component, instance and repetition numbers as a field name for submitted files
				var componentIndex      = $(this).parents('.row').data('data-index');
				var globalInstanceIndex = $(this).parents('.row').data('global-instance-index');
				var localInstanceIndex  = null;
				var repetitionIndex     = $(this).parents('.value').data('repetition');

				if(''+componentIndex in fileInstances){
					var componentInstances = fileInstances[''+componentIndex];
					localInstanceIndex = componentInstances.indexOf(globalInstanceIndex);
					if(localInstanceIndex == -1){
						// This is a new instance.
						localInstanceIndex = componentInstances.push(globalInstanceIndex) - 1;
					}else{
						// This is a new repetition.
					}
				}else{
					// This is a new component.
					fileInstances[''+componentIndex] = [
						globalInstanceIndex
					];
					localInstanceIndex = 0;
				}

				formData.append(
					'file'
						+ '_c' + componentIndex
						+ '_i' + localInstanceIndex
						+ '_r' + repetitionIndex,
					this.files[0]
				);
			});

			$.ajax({
				method:      'post',
				url:         Config.postURL,
				//data:        { json: JSON.stringify(postData) },
				data:        formData,
				dataType:    'json',
				processData: false,
				contentType: false
			}).done(function(data){
				if(!('success' in data) || (data.success !== true && !('message' in data))){
					alert('Error: Could not submit form');
				}else if(data.success !== true){
					alert('Error: Could not submit form: ' + data.message);
				}else{
					// OK
					console.log('form submitted successfully');
					if('message' in data)
						alert(data.message);
				}
			}).error(function(xhr, status, err){
				alert('Error: Could not submit form: ' + err.message);
			});
		}catch(ex){
			// This catches JSON stringify errors
			alert('Error: Could not submit form');
			console.log(ex);
			throw(ex);
		}finally{
			// Whatever happens, prevent the browser from submitting the form
			// itself and leaving the page.
			if(typeof(e) !== 'undefined') // Allow onSubmit() to be called without event context
				e.preventDefault();
			return false;
		}
	}

	// }}}
	// HTML generators, templates {{{

	// NOTE: Using $('<el>') to create elements and el.attr() to assign
	//       attributes would be a lot more readable, but unfortunately this
	//       is a lot slower than generating HTML strings ourselves.

	/**
	 * Replace occurrences of repetition index number placeholders with
	 * the instance's and their parents' repeat indices.
	 *
	 * @param string the string to replace occurrences in
	 * @param instance
	 * @param repeatIndex
	 * @param zeroBased (optional) if true, start counting at 0 instead of 1
	 *
	 * @return the modified string
	 */
	function replaceRepetitionPlaceholders(string, instance, repeatIndex, zeroBased){
		/**
		 * Get a list of placeholders and their values for this instance / repetition and its parents.
		 *
		 * @param instance
		 * @param repeatIndex
		 *
		 * @return a list of {placeholder: <>, value: <>}, ordered from outermost to innermost component
		 */
		function getPlaceholders(instance, repeatIndex){
			var placeholders = [];

			if('parentInstance' in instance && instance.parentInstance !== null)
				placeholders = getPlaceholders(instance.parentInstance, instance.parentRepetition);

			if(instance.component.repeat){
				// The repeat_index component property was not named very well.
				// It contains the placeholder string for repeatable components
				// (that should be replaced with a repeatIndex value).
				placeholders.unshift({
					placeholder: instance.component.repeat_index,
					value:       repeatIndex + (typeof(zeroBased) !== 'undefined' && zeroBased === true ? 0 : 1)
				});
			}
			return placeholders;
		}

		var placeholders = getPlaceholders(instance, repeatIndex);

		for(var i=0; i<placeholders.length; i++)
			string = string.replace(placeholders[i].placeholder, placeholders[i].value);

		return string;
	}

	/**
	 * Render repeat label and reset, add, remove buttons for a form component.
	 *
	 * @param instance a section or parameter instance
	 * @param repeatIndex an index number for repeated components, -1 if this is a dummy section / value
	 *
	 * @return a buttonSet div
	 */
	function makeButtonSet(instance, repeatIndex){
		if(typeof(repeatIndex) === 'undefined')
			repeatIndex = 0

		var buttonSet = '<div class="buttonset ' + instance.component.type + '-buttons'
			+ (instance.component.type === 'parameter' ? ' table-cell shrink align-right' : ' float-right')
			+ '">';

		if(instance.component.repeat){
			if(repeatIndex === -1){
				// Dummy repetition
				buttonSet +=
					(instance.component.type === 'section')
						? '(none - click to add)'
						: 'none';
			}else{
				buttonSet += '<span class="repetition-index">' + (repeatIndex + 1) + '</span>';
				if(instance.component.type === 'section'){
					buttonSet += ' / <span class="repetition-count">' + instance.repetitionCount + '</span>';
				}
			}
		}

		if(instance.component.type === 'parameter'){
			buttonSet += '<i title="Reset to default value ('
				+ replaceRepetitionPlaceholders(instance.component.default, instance, repeatIndex)
				+ ')" class="reset fa fa-fw fa-undo invisible"></i>';
		}else if(instance.component.type === 'section' && instance.component.repeat){
			// Don't crowd the interface too much.
			/*
			buttonSet += '<i title="Scroll towards the previous block of this type" class="next fa fa-fw fa-lg fa-caret-up'
				+ '"></i>';
			buttonSet += '<i title="Scroll towards the next block of this type" class="next fa fa-fw fa-lg fa-caret-down'
				+ '"></i>';
			*/
		}

		buttonSet += '<i title="Remove this ' + (instance.component.type === 'section' ? 'block' : 'value') + '" '
			+ 'class="minus fa fa-fw fa-minus'
			+ (!instance.component.repeat
				// Remove the line below if you decide to support adding / removing
				// repetitions that are not the last in their instance's repetitions array.
				|| (repeatIndex < instance.repetitionCount - 1)
				|| (instance.component.repeat_min === instance.repetitionCount)
				? ' invisible' : '')
			+ '"></i>';
		buttonSet += '<i title="Add a ' + (instance.component.type === 'section' ? 'block' : 'value') + '" '
			+ 'class="plus fa fa-fw fa-plus'
			+ (!instance.component.repeat
				// Remove the line below if you decide to support adding / removing
				// repetitions that are not the last in their instance's repetitions array.
				|| (repeatIndex < instance.repetitionCount - 1)
				|| (instance.component.repeat_max !== null && instance.repetitionCount >= instance.component.repeat_max)
				? ' invisible' : '')
			+ '"></i>';

		buttonSet += '</div>';

		return buttonSet;
	}

	/**
	 * Create a single section component repetition.
	 *
	 * It is an error to call this function with instantiate=true and repeatIndex=-1.
	 *
	 * @param instance the section instance to build
	 * @param repeatIndex an index number for repeated sections, -1 to render a dummy section
	 * @param instantiate (optional) if true, create new instances for all section children. also adds a repetition to the given instance.
	 *
	 * @return
	 *     if createChildren:
	 *         { children: [], html: <SectionAndChildrenHTML> }
	 *     else:
	 *         { start: <startHTML>, end: <endHTML> }
	 */
	function makeSection(instance, repeatIndex, instantiate){
		var sectionStart =
			  '<section' + (repeatIndex === -1 ? ' class="dummy"' : '')
			+ (repeatIndex !== -1 ? ' data-repetition="' + repeatIndex + '"' : '')
			+ '>'
			+ '<header>'
			+ '<i class="togglebutton fa fa-fw fa-lg fa-angle-double-down"></i>'
			+ '<span class="header-text">'
			+ replaceRepetitionPlaceholders(instance.component.label, instance, repeatIndex)
			+ '</span>'
			+ makeButtonSet(instance, repeatIndex)
			+ '</header>'
			+ '<div class="content">';

		var sectionEnd =
			  '</div>'
			+ '</section>';

		var html = {
			start: sectionStart,
			end:   sectionEnd
		};

		if(instantiate){
			if(repeatIndex === -1){
				alert('Error: Cannot create section children without a non-dummy parent (in makeSection())');
				return;
			}
			html.content = '';
			var children = [];
			instance.repetitions.push(children);

			// It would make the script too complicated if this function had an
			// option to render asynchronously (with a callback) when it has to
			// render children, so we use a simple blocking loop here.

			for(var i=0; i<instance.component.children.length; i++){

				// XXX: FIXME: Currently, this loop is mostly a duplication of renderComponents(),
				//             we may need to generalize this...
				// The main differences between this function and renderComponents()
				// are that this function takes a section instance instead
				// of a component list as an argument, and is synchronous as
				// opposed to asynchronous with callbacks.

				// XXX: Make sure to reflect changes made here in renderComponents().

				var childComponent = instance.component.children[i];
				if('hidden' in childComponent && childComponent.hidden)
					continue;

				var childInstance = {
					component:        childComponent,
					parentInstance:   instance,
					parentRepetition: repeatIndex,
					hasDummy:         false
				};

				childInstance.globalIndex = componentInstances.push(childInstance) - 1;
				children.push(childInstance);

				html.content += '<div class="row';
				if('accesslevels' in childComponent){
					var levelCount = childComponent.accesslevels.length;
					for(var j=0; j<levelCount; j++)
						html.content += ' level-' + childComponent.accesslevels[j];
				}

				html.content += '" data-data-index="'            + childComponent.dataIndex;
				html.content += '" data-global-instance-index="' + childInstance.globalIndex + '">';

				if(childComponent.type === 'section' || childComponent.type === 'parameter'){
					childInstance.repetitions     = [];
					childInstance.repetitionCount = childComponent.repeat ? childComponent.repeat_min : 1;
				}

				if(childComponent.type === 'section'){
					if(childComponent.repeat && childComponent.repeat_min == 0){
						childInstance.hasDummy = true;
						dummy = makeSection(childInstance, -1);
						html.content += dummy.html.start + dummy.html.end;
					}else{
						for(var j=0; j<childInstance.repetitionCount; j++){
							var subSection = makeSection(childInstance, j, true);
							html.content += subSection.html;
						}
					}
				}else{
					if(childComponent.type === 'parameter'){
						var parameter = makeParameterRepetitions(childInstance);
						html.content += parameter.html;
						childInstance.repetitions = parameter.repetitions;
						if(childComponent.repeat && childComponent.repeat_min == 0)
							childInstance.hasDummy = true;
					}else if(childComponent.type === 'paragraph'){
						html.content += makeParagraph(childInstance);
					}else{
						alert('Error: Can\'t render unknown component type: ' + childComponent.type);
					}
				}

				html.content += '</div>';
			}
		}

		if(instantiate){
			return {
				html: html.start + html.content + html.end,
				children: children
			};
		}else{
			return {
				html: html
			};
		}
	}

	/**
	 * Make repeat_min amount of sections, or 1 if repeat is not set.
	 * Does not create child instances.
	 *
	 * @param instance
	 * @param callback called with an array of repetitions, each having a html {start: S, end: S} property
	 */
	function makeSectionRepetitions(instance, callback){
		var repetitions = [];

		for(var i=0; i<(instance.component.repeat ? instance.component.repeat_min : 1); i++){
			var repetition = {
				html: makeSection(instance, i).html,
				children: []
			};

			repetitions.push(repetition);
		}

		return repetitions;
	}

	/**
	 * Create a value (input, select, checkbox group) for a parameter component.
	 *
	 * @param instance the parameter instance
	 * @param repeatIndex an index number for repeated parameters, -1 to render a dummy input
	 *
	 * @return { html: html, value: <default_value> }
	 */
	function makeValue(instance, repeatIndex){
		var valueHTML =
			  '<div class="value table-row'
			+ (repeatIndex === -1 ? ' dummy' : '')
			+ '"';
		if(repeatIndex !== -1)
			valueHTML += ' data-repetition="' + repeatIndex + '"';
		valueHTML += '>';

		var name = instance.component.name;
		/**
		 * Convenience function, @see replaceRepetitionPlaceholders()
		 *
		 * @param string
		 * @param zeroBased
		 *
		 * @return string
		 */
		function pfilter(string, zeroBased){
			return replaceRepetitionPlaceholders(string, instance, repeatIndex, zeroBased);
		}

		var id = 'f_' + pfilter(name);

		if(repeatIndex === -1){
			var input = '<input type="text" class="table-cell dummy invisible" disabled />';
		}else{
			if(instance.component.datatype === 'choice' && instance.component.options.length > 999){
				// Special case for radio buttons
				// TODO
				var input = '<div class="checkgroup table-cell" id="' + id + '" data-default="' + pfilter(instance.component.default) + '">';

				// List all the options
				optLen = instance.component.options.length;
				for(var i=0; i<optLen; i++){
					var checkbox = '<input type="radio" class="parameter" id="' + id + '_' + i + '" '
						+ 'name="' + pfilter(name) + '"' + (instance.component.default === instance.component.options[i] ? ' checked' : '')
						+ ' />';

					var label = '<label for="' + id + '_' + i + '">' + pfilter(instance.component.options[i]) + '</label>';
					input += label;
				}
			}else{
				// This is reusable for all datatypes
				var idNameDefaultAttrs = 'id="' + id + '" name="' + pfilter(name) + '" '
					+ 'data-default="' + pfilter(instance.component.default) + '"';

				if(instance.component.datatype === 'choice'){
					var input = '<select class="parameter table-cell" ' + idNameDefaultAttrs + '>';
					// Select options
					for(var i=0; i<instance.component.options.length; i++){
						input += '<option value="' + pfilter(instance.component.options[i]) + '"'
							+ (instance.component.default === instance.component.options[i] ? ' selected' : '') + '>'
							+ pfilter(instance.component.options[i]);
					}
					input += '</select>';
				}else if(instance.component.datatype === 'string'){
					var input = '<input type="text" ' + idNameDefaultAttrs
						+ ' value="' + pfilter(instance.component.default) + '" />';
				}else if(instance.component.datatype === 'integer'){
					var input = '<input type="text" pattern="-?\\d*" ' + idNameDefaultAttrs
						+ ' value="' + pfilter(instance.component.default) + '" />';
				}else if(instance.component.datatype === 'float'){
					var input = '<input type="text" pattern="-?\\d*(\\.\\d+)?" ' + idNameDefaultAttrs
						+ ' value="' + pfilter(instance.component.default) + '" />';
				}else if(instance.component.datatype === 'file'){
					var input = '<input type="file" ' + idNameDefaultAttrs + ' />';
				}else{
					alert('Error: Unknown datatype "' + instance.component.datatype + '"');
					return;
				}
			}
		}

		valueHTML += input;
		valueHTML += makeButtonSet(instance, repeatIndex);
		valueHTML += '</div>';

		return {
			'html':  valueHTML,
			'value': pfilter(instance.component.default)
		};
	}

	/**
	 * Create a labeled parameter.
	 *
	 * 'html' in the returned object is a HTML string containing all repetitions.
	 * 'repetitions' is a list of parameter values.
	 *
	 * @param instance the parameter instance to build
	 *
	 * @return { label: html, values: html, reptitions: [value, value, ...] }
	 */
	function makeParameterRepetitions(instance){
		var label = '<label for="f_'
			+ replaceRepetitionPlaceholders(instance.component.name, instance, 0)
			+ '" title="'
			+ '(' + instance.component.datatype + ') '
			+ replaceRepetitionPlaceholders(instance.component.name, instance, 0)
			+ ' = ' + instance.component.default + '">'
			+ (typeof(instance.component.label) === 'undefined'
				? replaceRepetitionPlaceholders(instance.component.name, instance, 0)
				: replaceRepetitionPlaceholders(instance.component.label, instance, 0)) + '</label>';

		var valuesHTML = '<div class="values table">';
		var repetitions = [];

		if(instance.component.repeat && instance.component.repeat_min == 0){
			// Minimum amount of values is zero, do not render an input
			var value = makeValue(instance, -1);
			valuesHTML += value.html;
		}else{
			for(var i=0; i<(instance.component.repeat ? instance.component.repeat_min : 1); i++){
				var value   = makeValue(instance, i);
				valuesHTML += value.html;
				repetitions.push(value.value);
			}
		}

		valuesHTML += '</div>';

		return { 'html': label + valuesHTML, 'repetitions': repetitions };
	}

	/**
	 * Create a documentation / standalone paragraph.
	 *
	 * @param instance the paragraph instance to build
	 *
	 * @return a paragraph element
	 */
	function makeParagraph(instance){
		var paragraph = '<p class="documentation">'
			+ replaceRepetitionPlaceholders(instance.component.text, instance, 0);
			+ '</p>';

		return paragraph;
	}

	/**
	 * Counts components.
	 * Fills componentData[].
	 * Adds instance arrays to components.
	 *
	 * @param components
	 * @param callback
	 */
	function prepareComponents(components, callback, weight){
		async.eachSeries(components, function(component, componentCallback){
			var hidden = false;

			if('hidden' in component && component.hidden){
				//componentCallback();
				//return;

				// Add hidden components to componentData as well.
				// They are not used within this webapplication and will not be
				// sent back to the server, but they need to be in this array to
				// keep component numbers consistent with the backend.

				hidden = true;
			}

			if(typeof(weight) === 'undefined')
				weight = 1;

			componentCount         += 1;
			componentInstanceCount += hidden ? 0 : weight;

			var dataIndex       = componentData.push(component) - 1;
			component.dataIndex = dataIndex;

			if(component.type === 'section'){
				prepareComponents(
					component.children,
					componentCallback,
					(
						hidden
						? 0
						: (
							component.repeat
							? weight * component.repeat_min
							: weight
						)
					)
				);
			}else{
				componentCallback();
			}
		}, callback);
	}

	/**
	 * Fills componentInstances[].
	 * Renders component instances.
	 *
	 * @param components
	 * @param callback called with the generated HTML string
	 */
	function renderComponents(components, callback, parentInstance, parentRepetition){
		var html = '';

		async.eachSeries(components, function(component, componentCallback){
			// XXX: Make sure to reflect changes made here in makeSection(),
			//      there is currently some duplicated code.

			if('hidden' in component && component.hidden){
				componentCallback();
				return;
			}

			var isRootComponent = (typeof(parentInstance) === 'undefined' || parentInstance === null);

			var instance = {
				component:        component,
				parentInstance:   isRootComponent ? null : parentInstance,
				parentRepetition: isRootComponent ? null : parentRepetition,
				hasDummy:         false
			};

			instance.globalIndex = componentInstances.push(instance) - 1;

			if(isRootComponent){
				rootInstances.push(instance);
			}else{
				parentInstance.repetitions[parentRepetition].push(instance);
			}

			html += '<div class="row';
			if('accesslevels' in component){
				var levelCount = component.accesslevels.length;
				for(var i=0; i<levelCount; i++)
					html += ' level-' + component.accesslevels[i];
			}

			html += '" data-data-index="'            + component.dataIndex;
			html += '" data-global-instance-index="' + instance.globalIndex + '">';

			if(component.type === 'section' || component.type === 'parameter'){
				instance.repetitions     = [];
				// repetitionCount is used throughout the file because at render time
				// not all repetitions may have been rendered yet, so the length of
				// the repetitions array can't be used to determine the amount of
				// initial repetitions.
				instance.repetitionCount = component.repeat ? component.repeat_min : 1;
			}

			if(component.type === 'section'){
				// Instead of simply leaving sections to makeSectionRepetitions(),
				// we need to handle the rendering of section children ourselves
				// here.
				//
				// renderComponents() is only used at form build time (it does
				// various initializations we don't want to repeat), so we
				// can't have makeSection() call renderComponents() for its
				// children when the user clicks on the 'add' button for a
				// repeatable section.
				if(component.repeat && component.repeat_min == 0){
					instance.hasDummy = true;
					var dummyHTML     = makeSection(instance, -1).html;
					dummyHTML         = dummyHTML.start + dummyHTML.end;

					html += dummyHTML;

					instancesRendered++;
					if(!(instancesRendered & 0x0f) || instancesRendered === componentInstanceCount){
						setProgress(instancesRendered / componentInstanceCount);
						$('#items-loaded').html(instancesRendered);
					}
					componentCallback();
				}else{
					var repetitions = makeSectionRepetitions(instance);
					async.timesSeries(repetitions.length, function(i, timesCallback){
						instance.repetitions.push(repetitions[i].children);
						html += repetitions[i].html.start;

						renderComponents(component.children, function(repetitionHTML){
							html += repetitionHTML;
							html += repetitions[i].html.end;
							timesCallback();
						}, instance, i);
					}, function(){
						html += '</div>';

						instancesRendered++;
						if(!(instancesRendered & 0x0f) || instancesRendered === componentInstanceCount){
							setProgress(instancesRendered / componentInstanceCount);
							$('#items-loaded').html(instancesRendered);
						}

						// To prevent hanging browsers on slow devices,
						// give the browser some time to respond to user
						// input and redraw the window.

						// Only do this for sections, not other components,
						// since it can be quite a performance hit.
						async.nextTick(componentCallback);
					});
				}
			}else{
				if(component.type === 'parameter'){
					// Parameters don't need a special case for repeat_min==0 here,
					// since they don't contain children that may need to be renderComponents()ed.
					var parameter = makeParameterRepetitions(instance);
					html += parameter.html;
					instance.repetitions = parameter.repetitions;
					if(component.repeat && component.repeat_min == 0)
						instance.hasDummy = true;
				}else if(component.type === 'paragraph'){
					html += makeParagraph(instance);
				}else{
					alert('Error: Can\'t render unknown component type: ' + component.type);
				}

				html += '</div>';
				instancesRendered++;
				if(!(instancesRendered & 0x0f) || instancesRendered === componentInstanceCount){
					setProgress(instancesRendered / componentInstanceCount);
					$('#items-loaded').html(instancesRendered);
				}
				componentCallback();
			}
		}, function(){
			callback(html);
		});
	}

	// }}}

	/**
	 * Attach event handlers.
	 * Basically, adds everything to the form that can't be saved in a cache.
	 *
	 * @param c_callback called on completion
	 */
	function finalizeForm(c_callback){
		async.series([
			function(callback){
				// Attach all event handlers here.
				// Only use delegated event handlers to avoid having to reattach
				// them when spawning extra component instances.

				$('#haddockform').on('click', 'section:not([class~="dummy"]) header', function(e){
					toggleSection($(this).parent('section'));
				});

				$('#haddockform').on('focus', 'input[type="text"]', function(e){
					// Automatically select input element contents on focus
					$(this).one('mouseup', function(){
						$(this).select();
						return false;
					})
					$(this).select();
				});

				$('#haddockform').on('change', 'input, select', function(e){
					formHasChanged = true;

					if(Config.showResetButton){
						if($(this).is('input[type="text"]') || $(this).is('select')){
							var buttonSet = $(this).parent('.value').find('.buttonset');
							if($(this).val() == $(this).attr('data-default')){
								buttonSet.find('.reset').addClass('invisible');
							}else if($(this).attr('data-default') !== ''){
								buttonSet.find('.reset').removeClass('invisible');
							}
						}else if($(this).is('.buttongroup')){
							// TODO: Radio buttons are currently not supported
							//buttonSet.find('.reset').removeClass('invisible');
						}
					}
				});

				$('#haddockform').on('click', '.buttonset i.reset',  onResetButton);
				$('#haddockform').on('click', '.buttonset i.minus',  onMinusButton);
				$('#haddockform').on('click', '.buttonset i.plus',   onPlusButton );

				$('.levelchooser').on('click', 'li', function(e){
					setLevel($(this).data('name'));
				});

				$('#haddockform').on('submit', onSubmit);

				callback();
			},
			function(callback){
				// Fold all sections
				$('#haddockform section').each(function(){ toggleSection(this, true); });
				// Set form level
				// This also enables the submit button
				setLevel(formLevel, true);
				// Show the form
				$('.loading').addClass('hidden');
				$('#haddockform').removeClass('hidden');
				formReady = true;
				async.nextTick(callback);
			}
		], c_callback);
	}

	/**
	 * Build a form with the specified list of components.
	 *
	 * @param components
	 * @param callback called on completion
	 */
	function buildForm(components, callback){
		// We're not hanging your browser, don't worry
		$('html').css('cursor', 'progress');

		var html;

		async.series([
			function(stepCallback){
				prepareComponents(components, function(){
					$('#items-total').html(componentInstanceCount);
					stepCallback();
				});
			},
			function(stepCallback){
				setProgress(0);
				$('#progress-activity').html('Building form');
				$('#form-progress, .progress-container').removeClass('hidden');
				renderComponents(components, function(renderedHTML){
					html = renderedHTML;
					stepCallback();
				});
			},
			function(stepCallback){
				$('#progress-activity').html('Rendering');
				//var progressbar = $('#progressbar');
				//progressbar.css('width', '');
				//progressbar.addClass('indeterminate');
				$('#form-progress').addClass('hidden');
				stepCallback();
			},
		], function(err){
			$('html').css('cursor', '');
			callback(html);
		});
	}

	// Serialization and unserialization of form data {{{

	/**
	 * Replace references to other objects in instances arrays with index numbers.
	 * Used to allow for JSON serialization.
	 *
	 * @param componentInstances
	 * @param rootInstances
	 * @param callback called with (deflatedComponentInstances, deflatedRootInstances)
	 */
	function deflateInstances(componentInstances, rootInstances, callback){
		async.series([
			function(stepCallback){
				var deflatedComponentInstances = [];

				async.eachSeries(componentInstances, function(instance, instanceCallback){
					var deflated = { };
					// Loop through instance properties and do conversions when necessary.
					for(var key in instance){
						if(key === 'component'){
							// Save the component index number instead of the component object itself.
							deflated.componentIndex = instance.component.dataIndex;
						}else if(key === 'parentInstance'){
							// Save the parent instance index number instead of the instance object itself.
							deflated.parentInstanceIndex = (instance.parentInstance === null)
								? null : instance.parentInstance.globalIndex;
						}else if(key === 'repetitions'){
							if(instance.component.type === 'section'){
								// For sections, we need to convert the children property of each repetition.
								deflated.repetitions = [];
								for(var i=0; i<instance.repetitions.length; i++){
									var children = [];
									for(var j=0; j<instance.repetitions[i].length; j++){
										// Save the child instance number instead of the instance itself.
										children.push(instance.repetitions[i][j].globalIndex);
									}
									deflated.repetitions.push(children);
								}
							}else if(instance.component.type === 'parameter'){
								// Simply create a copy of the parameter's repetitions array.
								// It only contains values.
								deflated.repetitions = instance.repetitions.slice(0);
							}else{
								// Other component types can't repeat.
								console.log('WARNING: Dropping instance property "' + key
									+ '" because repetition is not supported for component type "' + instance.component.type + '"');
							}
						}else if(instance[key] === null){
							// 'null' is an object in JS. We need a special check for it.
							deflated[key] = instance[key];
						}else if(typeof(instance[key]) === 'object'){
							// This catches arrays as well
							console.log('WARNING: Dropping instance property "' + key
								+ '" because it is not a scalar value (' + typeof(instance[key]) + ')');
						}else{
							deflated[key] = instance[key];
						}
					}

					deflatedComponentInstances.push(deflated);
					instanceCallback();
				}, function(){
					stepCallback(null, deflatedComponentInstances);
				});
			},
			function(stepCallback){
				var deflatedRootInstances = [];

				async.eachSeries(rootInstances, function(instance, instanceCallback){
					deflatedRootInstances.push(instance.globalIndex);
					instanceCallback();
				}, function(){
					stepCallback(null, deflatedRootInstances);
				});
			},
		], function(err, results){
			callback(results[0], results[1]);
		});
	}

	/**
	 * Does the opposite of deflateInstances().
	 * @see deflateInstances()
	 *
	 * @param componentInstances
	 * @param rootInstances
	 * @param callback called with (inflatedComponentInstances, inflatedRootInstances)
	 */
	function inflateInstances(componentInstances, rootInstances, callback){
		var inflatedComponentInstances = [];

		async.series([
			function(stepCallback){
				async.eachSeries(componentInstances, function(instance, instanceCallback){
					var inflated = { };
					// Loop through deflated instance properties and do conversions when necessary.
					for(var key in instance){
						if(key === 'componentIndex'){
							inflated.component = componentData[instance.componentIndex];
						}else if(key === 'parentInstanceIndex'){
							// The parent instance must be inflated already.
							inflated.parentInstance = (instance.parentInstanceIndex === null)
								? null : inflatedComponentInstances[instance.parentInstanceIndex];
						}else if(key === 'repetitions'){
							// Don't refer to inflated.component here, as we can't be sure
							// it has already been inflated.
							if(componentData[instance.componentIndex].type === 'section'){
								inflated.repetitions = [];
								for(var i=0; i<instance.repetitions.length; i++){
									var children = [];
									// The child instance objects need to be inserted
									// into its parent's children array by the children themselves,
									// since the children haven't yet been inflated at this point.
									inflated.repetitions.push([]);
								}
							}else if(componentData[instance.componentIndex].type === 'parameter'){
								// Simply create a copy of the parameter's repetitions array.
								// It only contains values.
								inflated.repetitions = instance.repetitions.slice(0);
							}else{
								console.log('WARNING: Dropping deflated instance property "' + key
									+ '" because repetition is not supported for component type "'
									+ componentData[instance.componentIndex].type + '"');
							}
						}else{
							inflated[key] = instance[key];
						}
					}

					if(inflated.parentInstance !== null && inflated.parentRepetition !== null){
						// We had to skip inflation of repetition children entries (see above),
						// so do it now.
						inflated.parentInstance.repetitions[inflated.parentRepetition].push(inflated);
					}

					inflatedComponentInstances.push(inflated);
					instanceCallback();
				}, function(){
					stepCallback(null, inflatedComponentInstances);
				});
			},
			function(stepCallback){
				// TODO: Check whether we really need rootInstances after form generation.
				var inflatedRootInstances = [];

				async.eachSeries(rootInstances, function(instanceIndex, instanceCallback){
					inflatedRootInstances.push(inflatedComponentInstances[instanceIndex]);
					instanceCallback();
				}, function(){
					stepCallback(null, inflatedRootInstances);
				});
			},
		], function(err, results){
			callback(results[0], results[1]);
		});
	}

	// }}}
	// Form storage / loading {{{

	/**
	 * Store all serializable information of this form, necessary for rebuilding
	 * it, in localStorage.
	 *
	 * Copies of the instances arrays will be modified to change them from a
	 * cyclic graph into a normal tree, to allow for JSON serialization.
	 * @see deflateInstances()
	 *
	 * @param html the generated form HTML
	 * @param componentData
	 * @param componentInstances
	 * @param rootInstances
	 */
	function storeForm(html, componentData, componentInstances, rootInstances, callback){
		localStorage.removeItem('haddock_form_version');
		localStorage.removeItem('haddock_form');
		localStorage.removeItem('haddock_form_components');
		localStorage.removeItem('haddock_form_instances');
		localStorage.removeItem('haddock_form_root_instances');


		localStorage.setItem('haddock_form', html);

		console.log('deflating components and instances for serialization');
		deflateInstances(componentInstances, rootInstances, function(
				deflatedComponentInstances, deflatedRootInstances){
			localStorage.setItem('haddock_form_components', JSON.stringify(componentData));
			localStorage.setItem('haddock_form_instances',  JSON.stringify(deflatedComponentInstances));
			localStorage.setItem('haddock_form_root_instances', JSON.stringify(deflatedRootInstances));
			localStorage.setItem('haddock_form_version',        modelVersionTag);
			console.log('stored new form version: ' + modelVersionTag);
			callback();
		});
	}

	/**
	 * Load the HADDOCK form.
	 *
	 * This will load the HTML and component instance data for the form either
	 * by using the localStorage cache or by generating it on page load using buildForm().
	 *
	 * @param forceRenew when true, no attempt is made to load the form from cache
	 */
	function loadForm(forceRenew, form_data){
		/**
		 * Convert a JSON string to an object with validation.
		 */
		function parseJSON(jsonData){
			if(typeof(jsonData) === 'undefined'
					|| jsonData === null
					|| jsonData === false
					|| !jsonData.length){
				return null;
			}
			try{
				var obj = JSON.parse(jsonData);
				return (typeof(obj) === 'object') ? obj : null;
			}catch(e){
				return null;
			}
		}

		var storedVersion = localStorage.getItem('haddock_form_version');
		if(typeof(forceRenew) !== 'undefined' && forceRenew){
			console.log('force-refreshing form, dropping html cache');
		}else if(typeof(storedVersion) === 'undefined'
				|| storedVersion === null
				|| storedVersion === false
				|| !storedVersion.length){
			// If only there were a cross-browser method of checking whether a localStorage key exists
			console.log('no form cache found, generating new form version ' + modelVersionTag);
		}else{
			// We seem to have saved form data, check if it's up to date and valid
			if(storedVersion === modelVersionTag){
				var savedForm          = localStorage.getItem('haddock_form');
				var savedComponentData = parseJSON(localStorage.getItem('haddock_form_components'));
				var savedInstances     = parseJSON(localStorage.getItem('haddock_form_instances'));
				var savedRootInstances = parseJSON(localStorage.getItem('haddock_form_root_instances'));

				if(typeof(savedForm) !== 'string' || !savedForm.length
						|| savedComponentData === null || savedInstances === null || savedRootInstances === null){
					console.log('stored form html version ' + storedVersion + ' is incomplete, regenerating form');
					savedForm = null;
				}else{
					console.log('stored form html version ' + storedVersion + ' is up to date');
				}
			}else{
				console.log('stored form html version ' + storedVersion + ' is out of date, generating new version '
					+ modelVersionTag);
			}
		}

		formVersion = modelVersionTag;

		// Did we successfully load an up to date form from cache?
		if(typeof(savedForm) === 'string' && savedForm.length){
			// Yes, unserialize saved instance arrays
			$('#haddockform > .content').html(savedForm);
			// Now the browser should be busy parsing the HTML.
			// (or it is hanging the thread on the call above)
			// Either way, continue by inflating those arrays.

			// Component data is acyclic
			componentData = savedComponentData;

			console.log('inflating component instance arrays');
			inflateInstances(savedInstances, savedRootInstances, function(
					inflatedComponentInstances, inflatedRootInstances){
				componentInstances = inflatedComponentInstances;
				rootInstances      = inflatedComponentInstances;

				console.log('successfully loaded form version ' + modelVersionTag);
				// We should now have the form and all required JS objects loaded.
				finalizeForm();
			});
		}else{
			// No, generate a new form and store it in cache
			async.waterfall([
				function(callback){
					buildForm(rootComponents, function(result){ callback(null, result); });
				},
				function(result, callback){
					// Note: [0].innerHTML should be faster than html() but the
					//       difference is barely noticable in FF, Chrome and Safari.
					//       Also, cross-browser compatibility would not be guaranteed.
					$('#haddockform > .content').html(result);
					storeForm(result, componentData, componentInstances, rootInstances, function(){
						// componentInstances should not be modified before it is saved
						finalizeForm();
					});
				}
			]);
		}
	}

	// }}}

	async.nextTick(function(){
		// Don't load from localStorage if the query string contains "nocache".
		// Doing an indexOf on the entire query string is a bit hacky,
		// but we do not have any other parameters, so it's OK for now.
		if(window.location.search.indexOf('nocache') === -1)
			loadForm();
		else
			loadForm(true);
	});

	// For debugging
	window.dumpInstances = function(){
		return componentInstances;
	}
});
